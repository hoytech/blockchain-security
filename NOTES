blockchain crypto primitives
  * randomness
    * bias
    * predictability
  * computational infeasability
  * hash functions
    * pigeon-hole principle
    * preimage vs. collision resistance
    * fuzzy hashes
    * birthday attacks
    * length extension attacks
    * rho method
  * signatures
    * elliptic curves
    * how are ethereum addresses generated
    * HID wallets
      * how they are basically CSPRNGs

  * assignment: Take home problem: Generate an ethereum address that starts with 0x1234



blockchain architecture
  * account-based versus UTXO
  * consensus
    * complete determinism
  * nonces
    * replay attacks
    * enforces ordering
  * gas
  * transactions
    * structure of transactions
    * errors
  * smart contracts
  * ganache



solidity programming
  * contract addresses
    ? create2
  * how deployment works
    * to field is 0
    * data contains code to be executed during deployment
  * storage/state
    * lack of privacy
    * merkle trees
  * solidity
  * bin/ABI
  * modifiers
  * msg.sender, etc
  * function selectors
  * fallback function
    * functions without valid selectors
    * only assume enough gas to log something
  * difference between .call and a transaction
    * visibility: private/public/external/internal
  * pure/view
  * payable
  * revert/assert/require
  * transactionality
  * EVM
  * ecrecover
  * Checks-Effects-Interactions pattern
    * https://solidity.readthedocs.io/en/v0.4.21/security-considerations.html#use-the-checks-effects-interactions-pattern
  * calling other contracts

  * some good examples for exercises: https://programtheblockchain.com/posts/
    * something like: https://programtheblockchain.com/posts/2018/07/11/writing-a-trivial-multisig-wallet/
    * remove the nonce for a replay attack






* transaction costs
  * 0 bytes are cheaper





smart contract security
  * attack model
    * third-party
    * underhanded
  * upgradability
  * can we detect if a user is a smart contract?
    * https://consensys.github.io/smart-contract-best-practices/recommendations/#avoid-using-extcodesize-to-check-for-externally-owned-accounts
  * on-chain data is public



on-chain randomness



Resource: https://consensys.github.io/smart-contract-best-practices/known_attacks/


attacks
  * integer over/under flows
    * twos complement
      * small negative numbers use a lot of gas
    * abs(most_negative_number)
  * reentrancy
    * the DAO
  * DoS with unexpected revert in attacker's fallback function
    * withdraw pattern
  * DoS with block gas limit
  * unexpectedly sending ether to a contract


* ERC-20 approval bug








https://consensys.github.io/smart-contract-best-practices/security_tools/



consensus level security
  * double spends
  * front-running
  * timestamp manipulation
  ? role of miners







assembly
  * reserved area: mstore(0x40, 0x60) at the very top reserves the first 64 bytes in memory for sha3 hashing. This is always there whether the contract needs it or not.
